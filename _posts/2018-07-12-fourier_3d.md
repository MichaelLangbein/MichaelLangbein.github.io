---
layout: post
title:  "Fourier Transform on Three-Dimensional Objects"
date:   2018-02-25 20:09:02 +0100
categories: fourier
---

This post is still in draft stage! I'll finish it up as soon as I find some time to write again.

$$ \newcommand{\Reals}[]{\mathbb{R}} $$
$$ \newcommand{\Complexes}[]{\mathbb{C}} $$
$$ \newcommand{\Naturals}[]{\mathbb{N}} $$
$$ \newcommand{\Fourier}[]{\mathcal{F}} $$
$$ \newcommand{\code}[1]{\verb ! #1 !} $$
$$ \newcommand{\times}{\cdot} $$

# Motivation

Like many people I first got into working with the Fourier transform when learning to work with music. It was neat how you could take a signal, find out what notes it consisted of and then adjust the signal to your liking by doing simple operations in the Fourier domain. For example you could add an octave on top of the most important note by just adding another frequency to the signal.

Really, a musical signal is only just a function of time, or, in more technical terms, a mapping $\Reals \to \Reals $. However, there is no reason why we should limit ourselves to only such functions. What about mappings of the form $ A^n \to B $, or $ A^n \to B^m $? It turns out that there is a way to decompose these functions into frequencies as well!

This opens up a whole new world of interesting transformations. For example, grayscale pictures can be viewed as a function mapping x- and y-coordinates onto a pixel-value between 0 and 255. Geometrical objects are commonly described as a mapping of some parameters to a vector $[x, y, z]$. 

What I initially found fascinating about the Fourier transform was how you could modify musical signals. Now that we have learned that you can just as well apply the Fourier transformation to geometrical objects, let's find out what it means to modify them in the Fourier domain! Is there such a thing as "adding an octave to a spere"? If so, what would the spere look like?


# A little bit of theory

Let's first back up a little bit. What does it actually mean to get the Fourier representation of a signal? Feel free to skip to the next section if you want to go to out implementation immediately.

Consider an inner product space $S$ with orthogonal base $B_S$. Any $\vec{s} \in S$ can be represented as a combination of the basevectors $\vec{b}_n \in B_S$, such that

$$\vec{s} = \sum \alpha_n \vec{b}_n $$

Since $B_S$ is orthogonal, the coefficients $\alpha_n$ are easy to obtain:

$$ \alpha_n = < \vec{s}, \vec{b_n} > $$

All this holds for any orthogonal base. Then how is a Fourier base special? Really, there isn't all that much special about the Fourier base, except that the coefficients $\alpha_n$ have a neat interpretation: they are the amplitudes of a wave with frequency $f_n$.

The Fourier Transform is a transform on $B$ that changes the base of $B$ to a set of functions that can be viewed as sine waves. If the signal we want to represent does indeed have some wave-like properties, this representation may be a lot more concise. Choosing to represent a signal by it's Fourier coefficients is a bit like choosing to describe a piece of music by it's notesheet instead of, say, a wav file. The information content remains the same, but from the notesheet we can extract some information way more easily from a notesheet than from the raw values of the wav file. Most people will be able to get at least a vague impression of a song from it's notes, but very few will be able to read *anything* out of the long list of speaker-positions that make out a wav file.


# An analytically solvable example

Soon we will make use of numpy's $\code{fft}$ methods to switch between the orinary- and the frequency-representation of a signal numerically. But to ensure that our program works as intended, it makes sense to first work out an analytical example. 

Consider the ellipsoid $\vec{b}(\theta, \phi)$, which can be parameterized as:

$$ x = r_x \cos(\theta) \cos(\phi) $$ \\
$$ y = r_y \cos(\theta) \sin(\phi) $$ \\
$$ z = r_z \sin(\theta)  $$ \\

This is a vector valued function, a mapping from $ \Theta \times \Phi \to \Reals^3 $. Usually, we'd now have to find a Fourier-base consisting of functions of the same form, but things bekome a lot easier when we realize that we can decompose this signal into one-dimensional functions: 

$$\vec{b}(\theta, \phi) = \vec{x} b_x(\theta, \phi) + \vec{y} b_y(\theta, \phi) + \vec{z} b_z(\theta, \phi) $$

Accordingly, the Fourier-decomposition can be split the same way:

$$ \Fourier(\vec{b}(\theta, \phi)) = \vec{x} \Fourier(b_x(\theta, \phi)) + \vec{y} \Fourier(b_y(\theta, \phi)) + \vec{z} \Fourier(b_z(\theta, \phi)) $$

Let us for now only consider the x-dimension. Here we have: 

$$ \alpha_x(f_\theta, f_\phi) = \Fourier(b_x(\theta, \phi)) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} \cos(\theta) \cos(\phi) e^{-2 \pi i (\theta f_\theta + \phi f_\phi)} d\theta d\phi $$

This seems like a daunting integral to solve at first, but we can neatly separate the $\theta$- and $\phi$-terms, yielding a much simpler product of integrals: 

$$  \alpha_x(f_\theta, f_\phi) = \int_{-\infty}^{\infty} \cos(\theta) e^{-2 \pi i \theta f_\theta} d\theta   \int_{-\infty}^{\infty} \cos(\phi) e^{-2 \pi i \phi f_\phi} d\phi  $$ \\
 $$  = \frac{1}{2}[ \delta(f_\theta - \frac{1}{2\pi}) + \delta(f_\theta + \frac{1}{2\pi}) ] \frac{1}{2}[ \delta(f_\phi - \frac{1}{2\pi}) + \delta(f_\phi + \frac{1}{2\pi}) ]  $$

 
